grammar dk.gms.dsl.DeviceDefinition with org.eclipse.xtext.common.Terminals

generate deviceDefinition "http://www.gms.dk/dsl/DeviceDefinition"

System:
	('import' imports += Import)*
	'System' name=ID ':'
	gateway = Gateway
	graphs += Graph*
;

Graph:
	'Graph' name=ID ':'
	'type' type = ImportRef
	'category' category = STRING
	'title' title = STRING
	'x' xlabel = STRING
	'y' ylabel = STRING
;
	
Gateway:
	'Gateway' name=ID ':'
	'mac' mac = MAC
	workers += Worker+
;

Worker:
	'Worker' name=ID ':'
	'mac' mac = MAC
	('sleep' 'for' sleepTime = INT timeUnit += TimeUnit)?
	('broadcast' 'for' broadcastTime = INT timeUnit += TimeUnit)?
	devices += (Sensor | Actuator)*
;

terminal MAC:
	HEXBYTE ('-'|':') HEXBYTE ('-'|':') HEXBYTE ('-'|':') HEXBYTE ('-'|':') HEXBYTE ('-'|':') HEXBYTE
;

terminal fragment HEXBYTE:
	('0'..'9'|'A'..'F')('0'..'9'|'A'..'F')
;

Sensor:
	'Sensor' type = ImportRef ':'
	'pins' '(' pins += INT* (',' pins += INT)* ')'
	'rate' sampleRate = Primitive
	(outputs += SensorOutput)*
	('behavior' behavior += SampleBehavior)?
	('predicate' predicate += Exp)?
	'graph' graph = [Graph]
;

SampleBehavior:
	type = ImportRef '(' args += Primary* (',' pins += Primary)* ')'
;

TimeUnit:
	{Second} ('second'|'seconds') | {Minute} ('minute'|'minutes') | {Hour} ('hour'|'hours')
;

Binding:
	name=ID
;

BindingRef:
	ref = [Binding]
;

Import:
	name=ID
;

ImportRef:
	ref = [Import]
;

SensorOutput:
	'out' (output=STRING)? 'as' binding = Binding ('with' 'mapping' mapping = Exp)?
;

Actuator:
	'Actuator' type = ImportRef ':'
	'pins' '(' pins += INT* (',' pins += INT)* ')'
	'Settings' ':' settings += Setting*
	'trigger' 'on' exp = Exp
;

Setting:
	binding = Binding '=' value=INT
;

terminal DECIMAL:
	'-'? INT ('.' INT)+
;

Primitive:
	{DecimalPrimitive} value = DECIMAL | {IntPrimitive} value=INT | {BooleanTrue} 'TRUE' | {BooleanFalse} 'FALSE'
;

Exp returns Expression:
	Factor (( {Plus.left=current} '+' | {Minus.left=current}  '-' ) right=Factor)*
;

Factor returns Expression:
	Compare (({Mult.left=current} '*' | {Div.left=current}  '/'  ) right=Compare)*
;

Compare returns Expression:
	CompareOrEquals (( {Greater.left=current} '>' | {Lesser.left=current}  '<' ) right=CompareOrEquals)*
;

CompareOrEquals returns Expression:
	EqualsOrNotEquals (({GreaterOrEquals.left=current} '>=' | {LesserOrEquals.left=current}  '<=' ) right=EqualsOrNotEquals)*
;

EqualsOrNotEquals returns Expression:
	AndOr (({Equals.left=current} '==' | {NotEquals.left=current}  '!=' ) right=AndOr)*
;

AndOr returns Expression:
	Primary (({And.left=current} 'and' | {Or.left=current}  'or' ) right=Primary)*
;

Primary returns Expression:
	Primitive  | Parenthesis | BindingRef | ExternalCall
;

ExternalCall:
	func = ImportRef '(' args += Exp? (',' args += Exp)* ')'
;

Parenthesis:
	'(' exp=Exp ')'
;