/*
 * generated by Xtext 2.26.0
 */
package dk.sdu.gms.dds.validation

import dk.sdu.gms.dds.deviceDefinition.Device
import dk.sdu.gms.dds.deviceDefinition.Actuator
import dk.sdu.gms.dds.deviceDefinition.Sensor
import dk.sdu.gms.dds.deviceDefinition.DeviceDefinitionPackage
import org.eclipse.xtext.validation.Check
import dk.sdu.gms.dds.sensors.SensorDefinition
import dk.sdu.gms.dds.actuators.ActuatorDefinition
import dk.sdu.gms.dds.DeviceDefinition
import dk.sdu.gms.dds.deviceDefinition.VariableUse
import org.eclipse.emf.ecore.EObject
import dk.sdu.gms.dds.deviceDefinition.InternalVariableUse
import dk.sdu.gms.dds.deviceDefinition.ExternalVariableUse
import dk.sdu.gms.dds.deviceDefinition.GraphVariableUse
import dk.sdu.gms.dds.deviceDefinition.Graph
import static dk.sdu.gms.dds.Utils.*
import dk.sdu.gms.dds.deviceDefinition.Worker

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DeviceDefinitionValidator extends AbstractDeviceDefinitionValidator {
	
	@Check
	def deviceExists (Device device) {
		val definition = DeviceDefinition.getDefinition(device);
		if (definition === null) {
			error('Unknown device \"' + device.type + "\"", DeviceDefinitionPackage.Literals.DEVICE__TYPE)
		}
	}

	@Check // Yes this code is gross, shut up.
	def checkDevicePins (Device device) {
		val hasAllPins = switch (device) {
			case Actuator: device.pins.size() == ActuatorDefinition.getActuatorDefinition(device as Actuator).pinCount
			case Sensor: device.pins.size() == SensorDefinition.getSensorDefinition(device as Sensor).pinCount
		}
		
		if (!hasAllPins) {
			switch (device) {
				case Actuator: warning('Device needs ' + ActuatorDefinition.getActuatorDefinition(device as Actuator).pinCount + " pins", 
					DeviceDefinitionPackage.Literals.DEVICE__PINS)
				case Sensor: warning('Device needs ' + SensorDefinition.getSensorDefinition(device as Sensor).pinCount + " pins", 
					DeviceDefinitionPackage.Literals.DEVICE__PINS)
			}
		}
	}
	
	@Check
	def checkGraphVariableUse (VariableUse use) {
		val hgp = hasGraphParent(use);
		switch (use) {
			InternalVariableUse: if (hgp) error('Can only reference worker variables from the same worker.', DeviceDefinitionPackage.Literals.VARIABLE_USE__REF)
			ExternalVariableUse: if (hgp) error('Can only reference worker variables from the same worker.', DeviceDefinitionPackage.Literals.VARIABLE_USE__REF)
			GraphVariableUse: if (!hgp) error('Can only reference other device variables from graphs.', DeviceDefinitionPackage.Literals.VARIABLE_USE__REF)
		}
	}
	
	def hasGraphParent (EObject obj) {
		var current = obj;
		while (current.eContainer !== null) {
			current = current.eContainer;
			if (current instanceof Graph) {
				return true;
			}
		}
		return false;
	}
	
	@Check
	def checkVariableUseOfPrior(ExternalVariableUse use) {
		val device = getParentOfType(use, typeof(Device))
		val referencedDevice = use.obj;
		
		val indexOfDevice = getParentOfType(device, typeof(Worker)).devices.indexOf(device);
		val indexOfReference = getParentOfType(referencedDevice, typeof(Worker)).devices.indexOf(referencedDevice);
		
		if (indexOfDevice < indexOfReference) {
			warning("Expression is referencing a binding from a device later in the loop. This will result in readings being from before last sleep. (at least " + getSleepTime(getParentOfType(device, typeof(Worker))) + " outdated)", DeviceDefinitionPackage.Literals.EXTERNAL_VARIABLE_USE__OBJ);
		}
	}
	
	def getSleepTime (Worker worker) {
		return worker.sleepTime + " " + timeUnitToString(worker.timeUnit);
	}
}
