grammar dk.sdu.gms.dds.DeviceDefinition with org.eclipse.xtext.common.Terminals

generate deviceDefinition "http://www.sdu.dk/gms/dds/DeviceDefinition"

System:
	'System' ':'
	'wifi' wifiSsid = STRING ('with' 'password' wifiPassword = STRING)?
	'mqtt' mqttHost = STRING ('with' 'username' mqttUsername = STRING 'and' 'password' mqttPassword = STRING)?
	gateway = Gateway
	graphs += Graph*
;

Graph:
	'Graph' type = ID name=ID ':'
	'category' category = STRING
	'title' title = STRING
	'x' xlabel = STRING
	'y' ylabel = STRING
	('sample' outputs += Exp)+
;
	
Gateway:
	'Gateway' name=ID ':'
	'mac' mac = MAC
	workers += Worker+
;

Worker:
	'Worker' (name=ID) ':'
	('mac' mac = MAC)
	('sleep' 'for' sleepTime = INT timeUnit = TimeUnit)?
	devices += Device*
;

Device:
	Sensor | Actuator
;

Sensor:
	'Sensor' type = ID name=ID ':'
	('pins' pins += Pin* (',' pins += Pin)*)?
	(outputs += SensorOutput)*
	(settings += Setting)*
	('sample' 'if' predicate += Exp)?
;

Pin:
	type = PinType number = INT
;

PinType:
	{ADC} 'adc' | {DAC} 'dac' | {GenericIn} 'in' | {GenericOut} 'out' 
;

TimeUnit:
	{Second} ('second'|'seconds') | {Minute} ('minute'|'minutes') | {Hour} ('hour'|'hours')
;

terminal MAC:
	HEXBYTE (':') HEXBYTE (':') HEXBYTE (':') HEXBYTE (':') HEXBYTE (':') HEXBYTE
;

terminal fragment HEXBYTE:
	('0'..'9'|'A'..'F')('0'..'9'|'A'..'F')
;

Binding:
	SensorOutput | Setting
;

SensorOutput:
	'out' (output=STRING)? 'as' name=ID ('with' 'mapping' mapping = Exp)?
;

Actuator:
	'Actuator' type = ID name=ID ':'
	'pins' pins += Pin* (',' pins += Pin)* 
	settings += Setting*
	trigger = Trigger
;

Trigger:
	{When} 'when' exp = Exp
	 | {OnOff} 'on' onExp = Exp (('off' offExp = Exp) | ('run' 'for' time=INT unit=TimeUnit))
;

Setting:
	'setting' name=ID '=' value=Primitive
;

terminal DECIMAL:
	'-'? INT ('.' INT)+
;

Primitive:
	{DecimalPrimitive} value = DECIMAL | {IntPrimitive} value=INT | {BooleanTrue} 'TRUE' | {BooleanFalse} 'FALSE'
;

Exp returns Expression:
	Factor (( {Plus.left=current} '+' | {Minus.left=current}  '-' ) right=Factor)*
;

Factor returns Expression:
	Compare (({Mult.left=current} '*' | {Div.left=current}  '/'  ) right=Compare)*
;

Compare returns Expression:
	CompareOrEquals (( {Greater.left=current} '>' | {Lesser.left=current}  '<' ) right=CompareOrEquals)*
;

CompareOrEquals returns Expression:
	EqualsOrNotEquals (({GreaterOrEquals.left=current} '>=' | {LesserOrEquals.left=current}  '<=' ) right=EqualsOrNotEquals)*
;

EqualsOrNotEquals returns Expression:
	AndOr (({Equals.left=current} '==' | {NotEquals.left=current}  '!=' ) right=AndOr)*
;

AndOr returns Expression:
	Primary (({And.left=current} 'and' | {Or.left=current}  'or' ) right=Primary)*
;

Primary returns Expression:
	 Primitive | Parenthesis | VariableUse | ExternalCall | {Value} 'value'
;

ExternalCall:
	'call' func = ID '(' args += Exp? (',' args += Exp)* ')'
;

InternalVariableUse:
	ref = [Binding]
;

ExternalVariableUse:
	obj = [Device] ('.'|'->') ref = [Binding] 
;

GraphVariableUse:
	worker = [Worker] ('.'|'->') device = [Device] ('.'|'->') ref = [Binding]
;

VariableUse:
	InternalVariableUse | ExternalVariableUse | GraphVariableUse
;

Parenthesis:
	'(' exp=Exp ')'
;