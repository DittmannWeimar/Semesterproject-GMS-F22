/*
 * generated by Xtext 2.26.0
 */
package dk.sdu.gms.dds.serializer;

import com.google.inject.Inject;
import dk.sdu.gms.dds.deviceDefinition.ADC;
import dk.sdu.gms.dds.deviceDefinition.Actuator;
import dk.sdu.gms.dds.deviceDefinition.And;
import dk.sdu.gms.dds.deviceDefinition.BooleanFalse;
import dk.sdu.gms.dds.deviceDefinition.BooleanTrue;
import dk.sdu.gms.dds.deviceDefinition.DAC;
import dk.sdu.gms.dds.deviceDefinition.DecimalPrimitive;
import dk.sdu.gms.dds.deviceDefinition.DeviceDefinitionPackage;
import dk.sdu.gms.dds.deviceDefinition.Div;
import dk.sdu.gms.dds.deviceDefinition.Equals;
import dk.sdu.gms.dds.deviceDefinition.ExternalCall;
import dk.sdu.gms.dds.deviceDefinition.ExternalVariableUse;
import dk.sdu.gms.dds.deviceDefinition.Gateway;
import dk.sdu.gms.dds.deviceDefinition.GenericIn;
import dk.sdu.gms.dds.deviceDefinition.GenericOut;
import dk.sdu.gms.dds.deviceDefinition.Graph;
import dk.sdu.gms.dds.deviceDefinition.GraphVariableUse;
import dk.sdu.gms.dds.deviceDefinition.Greater;
import dk.sdu.gms.dds.deviceDefinition.GreaterOrEquals;
import dk.sdu.gms.dds.deviceDefinition.Hour;
import dk.sdu.gms.dds.deviceDefinition.IntPrimitive;
import dk.sdu.gms.dds.deviceDefinition.InternalVariableUse;
import dk.sdu.gms.dds.deviceDefinition.Lesser;
import dk.sdu.gms.dds.deviceDefinition.LesserOrEquals;
import dk.sdu.gms.dds.deviceDefinition.Minus;
import dk.sdu.gms.dds.deviceDefinition.Minute;
import dk.sdu.gms.dds.deviceDefinition.Mult;
import dk.sdu.gms.dds.deviceDefinition.NotEquals;
import dk.sdu.gms.dds.deviceDefinition.OnOff;
import dk.sdu.gms.dds.deviceDefinition.Or;
import dk.sdu.gms.dds.deviceDefinition.Parenthesis;
import dk.sdu.gms.dds.deviceDefinition.Pin;
import dk.sdu.gms.dds.deviceDefinition.Plus;
import dk.sdu.gms.dds.deviceDefinition.Second;
import dk.sdu.gms.dds.deviceDefinition.Sensor;
import dk.sdu.gms.dds.deviceDefinition.SensorOutput;
import dk.sdu.gms.dds.deviceDefinition.Setting;
import dk.sdu.gms.dds.deviceDefinition.Value;
import dk.sdu.gms.dds.deviceDefinition.When;
import dk.sdu.gms.dds.deviceDefinition.Worker;
import dk.sdu.gms.dds.services.DeviceDefinitionGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DeviceDefinitionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DeviceDefinitionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DeviceDefinitionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DeviceDefinitionPackage.ADC:
				sequence_PinType(context, (ADC) semanticObject); 
				return; 
			case DeviceDefinitionPackage.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case DeviceDefinitionPackage.AND:
				sequence_AndOr(context, (And) semanticObject); 
				return; 
			case DeviceDefinitionPackage.BOOLEAN_FALSE:
				sequence_Primitive(context, (BooleanFalse) semanticObject); 
				return; 
			case DeviceDefinitionPackage.BOOLEAN_TRUE:
				sequence_Primitive(context, (BooleanTrue) semanticObject); 
				return; 
			case DeviceDefinitionPackage.DAC:
				sequence_PinType(context, (DAC) semanticObject); 
				return; 
			case DeviceDefinitionPackage.DECIMAL_PRIMITIVE:
				sequence_Primitive(context, (DecimalPrimitive) semanticObject); 
				return; 
			case DeviceDefinitionPackage.DIV:
				sequence_Factor(context, (Div) semanticObject); 
				return; 
			case DeviceDefinitionPackage.EQUALS:
				sequence_EqualsOrNotEquals(context, (Equals) semanticObject); 
				return; 
			case DeviceDefinitionPackage.EXTERNAL_CALL:
				sequence_ExternalCall(context, (ExternalCall) semanticObject); 
				return; 
			case DeviceDefinitionPackage.EXTERNAL_VARIABLE_USE:
				sequence_ExternalVariableUse(context, (ExternalVariableUse) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GATEWAY:
				sequence_Gateway(context, (Gateway) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GENERIC_IN:
				sequence_PinType(context, (GenericIn) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GENERIC_OUT:
				sequence_PinType(context, (GenericOut) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GRAPH:
				sequence_Graph(context, (Graph) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GRAPH_VARIABLE_USE:
				sequence_GraphVariableUse(context, (GraphVariableUse) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GREATER:
				sequence_Compare(context, (Greater) semanticObject); 
				return; 
			case DeviceDefinitionPackage.GREATER_OR_EQUALS:
				sequence_CompareOrEquals(context, (GreaterOrEquals) semanticObject); 
				return; 
			case DeviceDefinitionPackage.HOUR:
				sequence_TimeUnit(context, (Hour) semanticObject); 
				return; 
			case DeviceDefinitionPackage.INT_PRIMITIVE:
				sequence_Primitive(context, (IntPrimitive) semanticObject); 
				return; 
			case DeviceDefinitionPackage.INTERNAL_VARIABLE_USE:
				sequence_InternalVariableUse(context, (InternalVariableUse) semanticObject); 
				return; 
			case DeviceDefinitionPackage.LESSER:
				sequence_Compare(context, (Lesser) semanticObject); 
				return; 
			case DeviceDefinitionPackage.LESSER_OR_EQUALS:
				sequence_CompareOrEquals(context, (LesserOrEquals) semanticObject); 
				return; 
			case DeviceDefinitionPackage.MINUS:
				sequence_Exp(context, (Minus) semanticObject); 
				return; 
			case DeviceDefinitionPackage.MINUTE:
				sequence_TimeUnit(context, (Minute) semanticObject); 
				return; 
			case DeviceDefinitionPackage.MULT:
				sequence_Factor(context, (Mult) semanticObject); 
				return; 
			case DeviceDefinitionPackage.NOT_EQUALS:
				sequence_EqualsOrNotEquals(context, (NotEquals) semanticObject); 
				return; 
			case DeviceDefinitionPackage.ON_OFF:
				sequence_Trigger(context, (OnOff) semanticObject); 
				return; 
			case DeviceDefinitionPackage.OR:
				sequence_AndOr(context, (Or) semanticObject); 
				return; 
			case DeviceDefinitionPackage.PARENTHESIS:
				sequence_Parenthesis(context, (Parenthesis) semanticObject); 
				return; 
			case DeviceDefinitionPackage.PIN:
				sequence_Pin(context, (Pin) semanticObject); 
				return; 
			case DeviceDefinitionPackage.PLUS:
				sequence_Exp(context, (Plus) semanticObject); 
				return; 
			case DeviceDefinitionPackage.SECOND:
				sequence_TimeUnit(context, (Second) semanticObject); 
				return; 
			case DeviceDefinitionPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case DeviceDefinitionPackage.SENSOR_OUTPUT:
				sequence_SensorOutput(context, (SensorOutput) semanticObject); 
				return; 
			case DeviceDefinitionPackage.SETTING:
				sequence_Setting(context, (Setting) semanticObject); 
				return; 
			case DeviceDefinitionPackage.SYSTEM:
				sequence_System(context, (dk.sdu.gms.dds.deviceDefinition.System) semanticObject); 
				return; 
			case DeviceDefinitionPackage.VALUE:
				sequence_Primary(context, (Value) semanticObject); 
				return; 
			case DeviceDefinitionPackage.WHEN:
				sequence_Trigger(context, (When) semanticObject); 
				return; 
			case DeviceDefinitionPackage.WORKER:
				sequence_Worker(context, (Worker) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Device returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (
	 *         type=ID 
	 *         name=ID 
	 *         pins+=Pin* 
	 *         pins+=Pin* 
	 *         settings+=Setting* 
	 *         trigger=Trigger
	 *     )
	 * </pre>
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns And
	 *     Exp.Plus_1_0_0_0 returns And
	 *     Exp.Minus_1_0_1_0 returns And
	 *     Factor returns And
	 *     Factor.Mult_1_0_0_0 returns And
	 *     Factor.Div_1_0_1_0 returns And
	 *     Compare returns And
	 *     Compare.Greater_1_0_0_0 returns And
	 *     Compare.Lesser_1_0_1_0 returns And
	 *     CompareOrEquals returns And
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns And
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns And
	 *     EqualsOrNotEquals returns And
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns And
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns And
	 *     AndOr returns And
	 *     AndOr.And_1_0_0_0 returns And
	 *     AndOr.Or_1_0_1_0 returns And
	 *
	 * Constraint:
	 *     (left=AndOr_And_1_0_0_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_AndOr(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOrAccess().getAndLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndOrAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Or
	 *     Exp.Plus_1_0_0_0 returns Or
	 *     Exp.Minus_1_0_1_0 returns Or
	 *     Factor returns Or
	 *     Factor.Mult_1_0_0_0 returns Or
	 *     Factor.Div_1_0_1_0 returns Or
	 *     Compare returns Or
	 *     Compare.Greater_1_0_0_0 returns Or
	 *     Compare.Lesser_1_0_1_0 returns Or
	 *     CompareOrEquals returns Or
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns Or
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns Or
	 *     EqualsOrNotEquals returns Or
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Or
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Or
	 *     AndOr returns Or
	 *     AndOr.And_1_0_0_0 returns Or
	 *     AndOr.Or_1_0_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=AndOr_Or_1_0_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_AndOr(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOrAccess().getOrLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndOrAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns GreaterOrEquals
	 *     Exp.Plus_1_0_0_0 returns GreaterOrEquals
	 *     Exp.Minus_1_0_1_0 returns GreaterOrEquals
	 *     Factor returns GreaterOrEquals
	 *     Factor.Mult_1_0_0_0 returns GreaterOrEquals
	 *     Factor.Div_1_0_1_0 returns GreaterOrEquals
	 *     Compare returns GreaterOrEquals
	 *     Compare.Greater_1_0_0_0 returns GreaterOrEquals
	 *     Compare.Lesser_1_0_1_0 returns GreaterOrEquals
	 *     CompareOrEquals returns GreaterOrEquals
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns GreaterOrEquals
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns GreaterOrEquals
	 *
	 * Constraint:
	 *     (left=CompareOrEquals_GreaterOrEquals_1_0_0_0 right=EqualsOrNotEquals)
	 * </pre>
	 */
	protected void sequence_CompareOrEquals(ISerializationContext context, GreaterOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.GREATER_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.GREATER_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.GREATER_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.GREATER_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOrEqualsAccess().getGreaterOrEqualsLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOrEqualsAccess().getRightEqualsOrNotEqualsParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns LesserOrEquals
	 *     Exp.Plus_1_0_0_0 returns LesserOrEquals
	 *     Exp.Minus_1_0_1_0 returns LesserOrEquals
	 *     Factor returns LesserOrEquals
	 *     Factor.Mult_1_0_0_0 returns LesserOrEquals
	 *     Factor.Div_1_0_1_0 returns LesserOrEquals
	 *     Compare returns LesserOrEquals
	 *     Compare.Greater_1_0_0_0 returns LesserOrEquals
	 *     Compare.Lesser_1_0_1_0 returns LesserOrEquals
	 *     CompareOrEquals returns LesserOrEquals
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns LesserOrEquals
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns LesserOrEquals
	 *
	 * Constraint:
	 *     (left=CompareOrEquals_LesserOrEquals_1_0_1_0 right=EqualsOrNotEquals)
	 * </pre>
	 */
	protected void sequence_CompareOrEquals(ISerializationContext context, LesserOrEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.LESSER_OR_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.LESSER_OR_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.LESSER_OR_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.LESSER_OR_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOrEqualsAccess().getLesserOrEqualsLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOrEqualsAccess().getRightEqualsOrNotEqualsParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Greater
	 *     Exp.Plus_1_0_0_0 returns Greater
	 *     Exp.Minus_1_0_1_0 returns Greater
	 *     Factor returns Greater
	 *     Factor.Mult_1_0_0_0 returns Greater
	 *     Factor.Div_1_0_1_0 returns Greater
	 *     Compare returns Greater
	 *     Compare.Greater_1_0_0_0 returns Greater
	 *     Compare.Lesser_1_0_1_0 returns Greater
	 *
	 * Constraint:
	 *     (left=Compare_Greater_1_0_0_0 right=CompareOrEquals)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getGreaterLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightCompareOrEqualsParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Lesser
	 *     Exp.Plus_1_0_0_0 returns Lesser
	 *     Exp.Minus_1_0_1_0 returns Lesser
	 *     Factor returns Lesser
	 *     Factor.Mult_1_0_0_0 returns Lesser
	 *     Factor.Div_1_0_1_0 returns Lesser
	 *     Compare returns Lesser
	 *     Compare.Greater_1_0_0_0 returns Lesser
	 *     Compare.Lesser_1_0_1_0 returns Lesser
	 *
	 * Constraint:
	 *     (left=Compare_Lesser_1_0_1_0 right=CompareOrEquals)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Lesser semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.LESSER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.LESSER__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.LESSER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.LESSER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getLesserLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightCompareOrEqualsParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Equals
	 *     Exp.Plus_1_0_0_0 returns Equals
	 *     Exp.Minus_1_0_1_0 returns Equals
	 *     Factor returns Equals
	 *     Factor.Mult_1_0_0_0 returns Equals
	 *     Factor.Div_1_0_1_0 returns Equals
	 *     Compare returns Equals
	 *     Compare.Greater_1_0_0_0 returns Equals
	 *     Compare.Lesser_1_0_1_0 returns Equals
	 *     CompareOrEquals returns Equals
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns Equals
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns Equals
	 *     EqualsOrNotEquals returns Equals
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Equals
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Equals
	 *
	 * Constraint:
	 *     (left=EqualsOrNotEquals_Equals_1_0_0_0 right=AndOr)
	 * </pre>
	 */
	protected void sequence_EqualsOrNotEquals(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getEqualsLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getRightAndOrParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns NotEquals
	 *     Exp.Plus_1_0_0_0 returns NotEquals
	 *     Exp.Minus_1_0_1_0 returns NotEquals
	 *     Factor returns NotEquals
	 *     Factor.Mult_1_0_0_0 returns NotEquals
	 *     Factor.Div_1_0_1_0 returns NotEquals
	 *     Compare returns NotEquals
	 *     Compare.Greater_1_0_0_0 returns NotEquals
	 *     Compare.Lesser_1_0_1_0 returns NotEquals
	 *     CompareOrEquals returns NotEquals
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns NotEquals
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns NotEquals
	 *     EqualsOrNotEquals returns NotEquals
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns NotEquals
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns NotEquals
	 *
	 * Constraint:
	 *     (left=EqualsOrNotEquals_NotEquals_1_0_1_0 right=AndOr)
	 * </pre>
	 */
	protected void sequence_EqualsOrNotEquals(ISerializationContext context, NotEquals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.NOT_EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.NOT_EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.NOT_EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.NOT_EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getNotEqualsLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsOrNotEqualsAccess().getRightAndOrParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Minus
	 *     Exp.Plus_1_0_0_0 returns Minus
	 *     Exp.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Exp_Minus_1_0_1_0 right=Factor)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Plus
	 *     Exp.Plus_1_0_0_0 returns Plus
	 *     Exp.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Exp_Plus_1_0_0_0 right=Factor)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns ExternalCall
	 *     Exp.Plus_1_0_0_0 returns ExternalCall
	 *     Exp.Minus_1_0_1_0 returns ExternalCall
	 *     Factor returns ExternalCall
	 *     Factor.Mult_1_0_0_0 returns ExternalCall
	 *     Factor.Div_1_0_1_0 returns ExternalCall
	 *     Compare returns ExternalCall
	 *     Compare.Greater_1_0_0_0 returns ExternalCall
	 *     Compare.Lesser_1_0_1_0 returns ExternalCall
	 *     CompareOrEquals returns ExternalCall
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns ExternalCall
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns ExternalCall
	 *     EqualsOrNotEquals returns ExternalCall
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns ExternalCall
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns ExternalCall
	 *     AndOr returns ExternalCall
	 *     AndOr.And_1_0_0_0 returns ExternalCall
	 *     AndOr.Or_1_0_1_0 returns ExternalCall
	 *     Primary returns ExternalCall
	 *     ExternalCall returns ExternalCall
	 *
	 * Constraint:
	 *     (func=ID args+=Exp? args+=Exp*)
	 * </pre>
	 */
	protected void sequence_ExternalCall(ISerializationContext context, ExternalCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns ExternalVariableUse
	 *     Exp.Plus_1_0_0_0 returns ExternalVariableUse
	 *     Exp.Minus_1_0_1_0 returns ExternalVariableUse
	 *     Factor returns ExternalVariableUse
	 *     Factor.Mult_1_0_0_0 returns ExternalVariableUse
	 *     Factor.Div_1_0_1_0 returns ExternalVariableUse
	 *     Compare returns ExternalVariableUse
	 *     Compare.Greater_1_0_0_0 returns ExternalVariableUse
	 *     Compare.Lesser_1_0_1_0 returns ExternalVariableUse
	 *     CompareOrEquals returns ExternalVariableUse
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns ExternalVariableUse
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns ExternalVariableUse
	 *     EqualsOrNotEquals returns ExternalVariableUse
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns ExternalVariableUse
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns ExternalVariableUse
	 *     AndOr returns ExternalVariableUse
	 *     AndOr.And_1_0_0_0 returns ExternalVariableUse
	 *     AndOr.Or_1_0_1_0 returns ExternalVariableUse
	 *     Primary returns ExternalVariableUse
	 *     ExternalVariableUse returns ExternalVariableUse
	 *     VariableUse returns ExternalVariableUse
	 *
	 * Constraint:
	 *     (obj=[Device|ID] ref=[Binding|ID])
	 * </pre>
	 */
	protected void sequence_ExternalVariableUse(ISerializationContext context, ExternalVariableUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.EXTERNAL_VARIABLE_USE__OBJ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.EXTERNAL_VARIABLE_USE__OBJ));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.VARIABLE_USE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.VARIABLE_USE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalVariableUseAccess().getObjDeviceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(DeviceDefinitionPackage.Literals.EXTERNAL_VARIABLE_USE__OBJ, false));
		feeder.accept(grammarAccess.getExternalVariableUseAccess().getRefBindingIDTerminalRuleCall_2_0_1(), semanticObject.eGet(DeviceDefinitionPackage.Literals.VARIABLE_USE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Div
	 *     Exp.Plus_1_0_0_0 returns Div
	 *     Exp.Minus_1_0_1_0 returns Div
	 *     Factor returns Div
	 *     Factor.Mult_1_0_0_0 returns Div
	 *     Factor.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (left=Factor_Div_1_0_1_0 right=Compare)
	 * </pre>
	 */
	protected void sequence_Factor(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Mult
	 *     Exp.Plus_1_0_0_0 returns Mult
	 *     Exp.Minus_1_0_1_0 returns Mult
	 *     Factor returns Mult
	 *     Factor.Mult_1_0_0_0 returns Mult
	 *     Factor.Div_1_0_1_0 returns Mult
	 *
	 * Constraint:
	 *     (left=Factor_Mult_1_0_0_0 right=Compare)
	 * </pre>
	 */
	protected void sequence_Factor(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.MULT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.MULT__LEFT));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.MULT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.MULT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getMultLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Gateway returns Gateway
	 *
	 * Constraint:
	 *     (name=ID mac=MAC workers+=Worker+)
	 * </pre>
	 */
	protected void sequence_Gateway(ISerializationContext context, Gateway semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns GraphVariableUse
	 *     Exp.Plus_1_0_0_0 returns GraphVariableUse
	 *     Exp.Minus_1_0_1_0 returns GraphVariableUse
	 *     Factor returns GraphVariableUse
	 *     Factor.Mult_1_0_0_0 returns GraphVariableUse
	 *     Factor.Div_1_0_1_0 returns GraphVariableUse
	 *     Compare returns GraphVariableUse
	 *     Compare.Greater_1_0_0_0 returns GraphVariableUse
	 *     Compare.Lesser_1_0_1_0 returns GraphVariableUse
	 *     CompareOrEquals returns GraphVariableUse
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns GraphVariableUse
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns GraphVariableUse
	 *     EqualsOrNotEquals returns GraphVariableUse
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns GraphVariableUse
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns GraphVariableUse
	 *     AndOr returns GraphVariableUse
	 *     AndOr.And_1_0_0_0 returns GraphVariableUse
	 *     AndOr.Or_1_0_1_0 returns GraphVariableUse
	 *     Primary returns GraphVariableUse
	 *     GraphVariableUse returns GraphVariableUse
	 *     VariableUse returns GraphVariableUse
	 *
	 * Constraint:
	 *     (worker=[Worker|ID] device=[Device|ID] ref=[Binding|ID])
	 * </pre>
	 */
	protected void sequence_GraphVariableUse(ISerializationContext context, GraphVariableUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.GRAPH_VARIABLE_USE__WORKER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.GRAPH_VARIABLE_USE__WORKER));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.GRAPH_VARIABLE_USE__DEVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.GRAPH_VARIABLE_USE__DEVICE));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.VARIABLE_USE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.VARIABLE_USE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGraphVariableUseAccess().getWorkerWorkerIDTerminalRuleCall_0_0_1(), semanticObject.eGet(DeviceDefinitionPackage.Literals.GRAPH_VARIABLE_USE__WORKER, false));
		feeder.accept(grammarAccess.getGraphVariableUseAccess().getDeviceDeviceIDTerminalRuleCall_2_0_1(), semanticObject.eGet(DeviceDefinitionPackage.Literals.GRAPH_VARIABLE_USE__DEVICE, false));
		feeder.accept(grammarAccess.getGraphVariableUseAccess().getRefBindingIDTerminalRuleCall_4_0_1(), semanticObject.eGet(DeviceDefinitionPackage.Literals.VARIABLE_USE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Graph returns Graph
	 *
	 * Constraint:
	 *     (
	 *         type=ID 
	 *         name=ID 
	 *         category=STRING 
	 *         title=STRING 
	 *         xlabel=STRING 
	 *         ylabel=STRING 
	 *         outputs+=Exp+
	 *     )
	 * </pre>
	 */
	protected void sequence_Graph(ISerializationContext context, Graph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns InternalVariableUse
	 *     Exp.Plus_1_0_0_0 returns InternalVariableUse
	 *     Exp.Minus_1_0_1_0 returns InternalVariableUse
	 *     Factor returns InternalVariableUse
	 *     Factor.Mult_1_0_0_0 returns InternalVariableUse
	 *     Factor.Div_1_0_1_0 returns InternalVariableUse
	 *     Compare returns InternalVariableUse
	 *     Compare.Greater_1_0_0_0 returns InternalVariableUse
	 *     Compare.Lesser_1_0_1_0 returns InternalVariableUse
	 *     CompareOrEquals returns InternalVariableUse
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns InternalVariableUse
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns InternalVariableUse
	 *     EqualsOrNotEquals returns InternalVariableUse
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns InternalVariableUse
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns InternalVariableUse
	 *     AndOr returns InternalVariableUse
	 *     AndOr.And_1_0_0_0 returns InternalVariableUse
	 *     AndOr.Or_1_0_1_0 returns InternalVariableUse
	 *     Primary returns InternalVariableUse
	 *     InternalVariableUse returns InternalVariableUse
	 *     VariableUse returns InternalVariableUse
	 *
	 * Constraint:
	 *     ref=[Binding|ID]
	 * </pre>
	 */
	protected void sequence_InternalVariableUse(ISerializationContext context, InternalVariableUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.VARIABLE_USE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.VARIABLE_USE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInternalVariableUseAccess().getRefBindingIDTerminalRuleCall_0_1(), semanticObject.eGet(DeviceDefinitionPackage.Literals.VARIABLE_USE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Parenthesis
	 *     Exp.Plus_1_0_0_0 returns Parenthesis
	 *     Exp.Minus_1_0_1_0 returns Parenthesis
	 *     Factor returns Parenthesis
	 *     Factor.Mult_1_0_0_0 returns Parenthesis
	 *     Factor.Div_1_0_1_0 returns Parenthesis
	 *     Compare returns Parenthesis
	 *     Compare.Greater_1_0_0_0 returns Parenthesis
	 *     Compare.Lesser_1_0_1_0 returns Parenthesis
	 *     CompareOrEquals returns Parenthesis
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns Parenthesis
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns Parenthesis
	 *     EqualsOrNotEquals returns Parenthesis
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Parenthesis
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Parenthesis
	 *     AndOr returns Parenthesis
	 *     AndOr.And_1_0_0_0 returns Parenthesis
	 *     AndOr.Or_1_0_1_0 returns Parenthesis
	 *     Primary returns Parenthesis
	 *     Parenthesis returns Parenthesis
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Parenthesis(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.PARENTHESIS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.PARENTHESIS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesisAccess().getExpExpParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PinType returns ADC
	 *
	 * Constraint:
	 *     {ADC}
	 * </pre>
	 */
	protected void sequence_PinType(ISerializationContext context, ADC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PinType returns DAC
	 *
	 * Constraint:
	 *     {DAC}
	 * </pre>
	 */
	protected void sequence_PinType(ISerializationContext context, DAC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PinType returns GenericIn
	 *
	 * Constraint:
	 *     {GenericIn}
	 * </pre>
	 */
	protected void sequence_PinType(ISerializationContext context, GenericIn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PinType returns GenericOut
	 *
	 * Constraint:
	 *     {GenericOut}
	 * </pre>
	 */
	protected void sequence_PinType(ISerializationContext context, GenericOut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pin returns Pin
	 *
	 * Constraint:
	 *     (type=PinType number=INT)
	 * </pre>
	 */
	protected void sequence_Pin(ISerializationContext context, Pin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.PIN__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.PIN__TYPE));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.PIN__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.PIN__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPinAccess().getTypePinTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPinAccess().getNumberINTTerminalRuleCall_1_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Value
	 *     Exp.Plus_1_0_0_0 returns Value
	 *     Exp.Minus_1_0_1_0 returns Value
	 *     Factor returns Value
	 *     Factor.Mult_1_0_0_0 returns Value
	 *     Factor.Div_1_0_1_0 returns Value
	 *     Compare returns Value
	 *     Compare.Greater_1_0_0_0 returns Value
	 *     Compare.Lesser_1_0_1_0 returns Value
	 *     CompareOrEquals returns Value
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns Value
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns Value
	 *     EqualsOrNotEquals returns Value
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns Value
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns Value
	 *     AndOr returns Value
	 *     AndOr.And_1_0_0_0 returns Value
	 *     AndOr.Or_1_0_1_0 returns Value
	 *     Primary returns Value
	 *
	 * Constraint:
	 *     {Value}
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primitive returns BooleanFalse
	 *     Exp returns BooleanFalse
	 *     Exp.Plus_1_0_0_0 returns BooleanFalse
	 *     Exp.Minus_1_0_1_0 returns BooleanFalse
	 *     Factor returns BooleanFalse
	 *     Factor.Mult_1_0_0_0 returns BooleanFalse
	 *     Factor.Div_1_0_1_0 returns BooleanFalse
	 *     Compare returns BooleanFalse
	 *     Compare.Greater_1_0_0_0 returns BooleanFalse
	 *     Compare.Lesser_1_0_1_0 returns BooleanFalse
	 *     CompareOrEquals returns BooleanFalse
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns BooleanFalse
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns BooleanFalse
	 *     EqualsOrNotEquals returns BooleanFalse
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns BooleanFalse
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns BooleanFalse
	 *     AndOr returns BooleanFalse
	 *     AndOr.And_1_0_0_0 returns BooleanFalse
	 *     AndOr.Or_1_0_1_0 returns BooleanFalse
	 *     Primary returns BooleanFalse
	 *
	 * Constraint:
	 *     {BooleanFalse}
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, BooleanFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primitive returns BooleanTrue
	 *     Exp returns BooleanTrue
	 *     Exp.Plus_1_0_0_0 returns BooleanTrue
	 *     Exp.Minus_1_0_1_0 returns BooleanTrue
	 *     Factor returns BooleanTrue
	 *     Factor.Mult_1_0_0_0 returns BooleanTrue
	 *     Factor.Div_1_0_1_0 returns BooleanTrue
	 *     Compare returns BooleanTrue
	 *     Compare.Greater_1_0_0_0 returns BooleanTrue
	 *     Compare.Lesser_1_0_1_0 returns BooleanTrue
	 *     CompareOrEquals returns BooleanTrue
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns BooleanTrue
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns BooleanTrue
	 *     EqualsOrNotEquals returns BooleanTrue
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns BooleanTrue
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns BooleanTrue
	 *     AndOr returns BooleanTrue
	 *     AndOr.And_1_0_0_0 returns BooleanTrue
	 *     AndOr.Or_1_0_1_0 returns BooleanTrue
	 *     Primary returns BooleanTrue
	 *
	 * Constraint:
	 *     {BooleanTrue}
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, BooleanTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primitive returns DecimalPrimitive
	 *     Exp returns DecimalPrimitive
	 *     Exp.Plus_1_0_0_0 returns DecimalPrimitive
	 *     Exp.Minus_1_0_1_0 returns DecimalPrimitive
	 *     Factor returns DecimalPrimitive
	 *     Factor.Mult_1_0_0_0 returns DecimalPrimitive
	 *     Factor.Div_1_0_1_0 returns DecimalPrimitive
	 *     Compare returns DecimalPrimitive
	 *     Compare.Greater_1_0_0_0 returns DecimalPrimitive
	 *     Compare.Lesser_1_0_1_0 returns DecimalPrimitive
	 *     CompareOrEquals returns DecimalPrimitive
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns DecimalPrimitive
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns DecimalPrimitive
	 *     EqualsOrNotEquals returns DecimalPrimitive
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns DecimalPrimitive
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns DecimalPrimitive
	 *     AndOr returns DecimalPrimitive
	 *     AndOr.And_1_0_0_0 returns DecimalPrimitive
	 *     AndOr.Or_1_0_1_0 returns DecimalPrimitive
	 *     Primary returns DecimalPrimitive
	 *
	 * Constraint:
	 *     value=DECIMAL
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, DecimalPrimitive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.DECIMAL_PRIMITIVE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.DECIMAL_PRIMITIVE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueDECIMALTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primitive returns IntPrimitive
	 *     Exp returns IntPrimitive
	 *     Exp.Plus_1_0_0_0 returns IntPrimitive
	 *     Exp.Minus_1_0_1_0 returns IntPrimitive
	 *     Factor returns IntPrimitive
	 *     Factor.Mult_1_0_0_0 returns IntPrimitive
	 *     Factor.Div_1_0_1_0 returns IntPrimitive
	 *     Compare returns IntPrimitive
	 *     Compare.Greater_1_0_0_0 returns IntPrimitive
	 *     Compare.Lesser_1_0_1_0 returns IntPrimitive
	 *     CompareOrEquals returns IntPrimitive
	 *     CompareOrEquals.GreaterOrEquals_1_0_0_0 returns IntPrimitive
	 *     CompareOrEquals.LesserOrEquals_1_0_1_0 returns IntPrimitive
	 *     EqualsOrNotEquals returns IntPrimitive
	 *     EqualsOrNotEquals.Equals_1_0_0_0 returns IntPrimitive
	 *     EqualsOrNotEquals.NotEquals_1_0_1_0 returns IntPrimitive
	 *     AndOr returns IntPrimitive
	 *     AndOr.And_1_0_0_0 returns IntPrimitive
	 *     AndOr.Or_1_0_1_0 returns IntPrimitive
	 *     Primary returns IntPrimitive
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, IntPrimitive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.INT_PRIMITIVE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.INT_PRIMITIVE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Binding returns SensorOutput
	 *     SensorOutput returns SensorOutput
	 *
	 * Constraint:
	 *     (output=STRING? name=ID mapping=Exp?)
	 * </pre>
	 */
	protected void sequence_SensorOutput(ISerializationContext context, SensorOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Device returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         type=ID 
	 *         name=ID 
	 *         pins+=Pin* 
	 *         pins+=Pin* 
	 *         outputs+=SensorOutput* 
	 *         settings+=Setting* 
	 *         predicate+=Exp?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Binding returns Setting
	 *     Setting returns Setting
	 *
	 * Constraint:
	 *     (name=ID value=Primitive)
	 * </pre>
	 */
	protected void sequence_Setting(ISerializationContext context, Setting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.BINDING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.BINDING__NAME));
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.SETTING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.SETTING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSettingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSettingAccess().getValuePrimitiveParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (
	 *         wifiSsid=STRING 
	 *         wifiPassword=STRING? 
	 *         mqttHost=STRING 
	 *         (mqttUsername=STRING mqttPassword=STRING)? 
	 *         gateway=Gateway 
	 *         graphs+=Graph*
	 *     )
	 * </pre>
	 */
	protected void sequence_System(ISerializationContext context, dk.sdu.gms.dds.deviceDefinition.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeUnit returns Hour
	 *
	 * Constraint:
	 *     {Hour}
	 * </pre>
	 */
	protected void sequence_TimeUnit(ISerializationContext context, Hour semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeUnit returns Minute
	 *
	 * Constraint:
	 *     {Minute}
	 * </pre>
	 */
	protected void sequence_TimeUnit(ISerializationContext context, Minute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeUnit returns Second
	 *
	 * Constraint:
	 *     {Second}
	 * </pre>
	 */
	protected void sequence_TimeUnit(ISerializationContext context, Second semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns OnOff
	 *
	 * Constraint:
	 *     (onExp=Exp (offExp=Exp | (time=INT unit=TimeUnit)))
	 * </pre>
	 */
	protected void sequence_Trigger(ISerializationContext context, OnOff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns When
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Trigger(ISerializationContext context, When semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeviceDefinitionPackage.Literals.WHEN__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeviceDefinitionPackage.Literals.WHEN__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTriggerAccess().getExpExpParserRuleCall_0_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Worker returns Worker
	 *
	 * Constraint:
	 *     (name=ID mac=MAC (sleepTime=INT timeUnit=TimeUnit)? devices+=Device*)
	 * </pre>
	 */
	protected void sequence_Worker(ISerializationContext context, Worker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
